#!/usr/bin/env python
NAME = "alterx.py";
VERSION = "1.1.2";
def say2():
	from sys import stderr
	w = stderr.write
	def O(*s):
		o = None
		for _ in s:
			if o is None:
				o = w
			else:
				o(' ')
			o(str(_))
		if o:
			o('\n')
		else:
			w('\n')
	return O
say2 = say2()
def say1():
	from sys import stdout
	w = stdout.write
	def O(*s):
		o = None
		for _ in s:
			if o is None:
				o = w
			else:
				o(' ')
			o(str(_))
		if o:
			o('\n')
		else:
			w('\n')
	return O
say1 = say1()
class iteropt:
	class StringObj:
		def __init__(self, s):
			self.s = s
		def __str__(self):
			return self.s
# constructor:
	def __init__(self, a=None):
		if a is None:
			from sys import argv
			a = iter(argv)
			try: # skip prog name
				if hasattr(a, '__next__'):
					a.__next__()
				else:
					a.next()
			except StopIteration:
				a = None
		else:
			a = iter(a)
		self.reset()
		self._arg = None
		self._argsrcs = []
		a and self._argsrcs.append(a)
# private:
	def _shift(self, jump=None):
		ss = self._argsrcs
		while len(ss) > 0:
			s = ss[0]
			try:
				if hasattr(s, '__next__'):
					return s.__next__()
				else:
					return s.next()
			except StopIteration:
				pass
			ss.pop(0), self.reset()
			if jump:
				break
		return None
# public:
	def reset(self):
		self._plain = None
# public:
	def is_plain(self, *a):
		r = self.get_plain(*a)
		if r is None:
			return None
		self.plain = r
		return True
	def is_bool(self, *a):
		#~ say2('is_bool', repr(self), repr(a))
		r = self.get_bool(*a)
		if r is None:
			return None
		self.bool = not not r.value
		self.name = r.name
		return True
	def is_true(self, *a):
		if not self.is_bool(*a):
			return None
		elif not self.bool:
			raise RuntimeError('Unexpected false boolean for: ' + self.name)
		return True
	def is_string(self, *a):
		r = self.get_value(*a)
		if r is None:
			return None
		self.string = r.value
		self.name = r.name
		return True
	def is_integer(self, *a):
		r = self.get_value(*a)
		if r is None:
			return None
		self.integer = int(r.value)
		self.name = r.name
		return True
	def is_float(self, *a):
		r = self.get_value(*a)
		if r is None:
			return None
		self.float = float(r.value)
		self.name = r.name
		return True
# public:
	def is_plain_form(self):
		return self._plain and self._arg and (not hasattr(self._arg, 's'))
	def is_long_form(self):
		return self._arg and hasattr(self._arg, 's') and (not hasattr(self._arg, 'bundle'))
	def is_short_form(self):
		return self._arg and hasattr(self._arg, 's') and hasattr(self._arg, 'bundle')
	def is_valid(self):
		return self._arg and True
# private:
	def _get_p(self, *args):
		r = self._arg
		if args and (r not in args):
			return None
		self._arg = None
		return r
	def _get_d_b(self, *args):
		#~ say2('_get_d_b', repr(self), repr(args))
		r = self._arg
		if r.name2 in args:
			r.index += 1
			(r.name, r.value) = (r.name2, True)
			if r.index < len(r.bundle):
				(r.name2, r.proceed)  = (r.bundle[ r.index ], True)
			else:
				self._arg = None
			return r
		return None
	def _get_d_v(self, *args):
		r = self._arg
		if r.name2 in args:
			r.index += 1
			#~ raise ValueError(str(self._arg))
			r.value = (r.index < len(r.bundle)) and r.bundle[ self._arg.index : ] or self._shift()
			if r.value is not None:
				(r.name, self._arg) = (r.name2, None)
			return r
		return None
	def _get_dd_v(self, *args):
		key = self._arg.name2
		for name in args:
			if key == name:
				self._arg.name = name
				self._arg.value = self._shift()
				if self._arg.value is not None:
					key = self._arg
					self._arg = None
					return key
				raise ValueError(str(self._arg))
		return None
	def _get_dde_v(self, *args):
		key = self._arg.name
		for name in args:
			if key == name:
				key = self._arg
				self._arg = None
				return key
		return None
	def _get_dd_b(self, *args):
		key = self._arg.name
		for name in args:
			if key == name:
				key = self._arg
				self._arg = None
				return key
		return None
# public:
	def next(self):
		m = None
		if self._arg is not None:
			if getattr(self._arg, 'proceed', None):
				self._arg.proceed = None
				return 1
			else:
				raise RuntimeError('Invalid argument: ' + str(self._arg))
		self.get_value = lambda *a: None
		self.get_bool = lambda *a: None
		self.get_plain = lambda *a: None
		for _ in ('plain','bool','string','integer','float','name'):
			hasattr(self, _) and delattr(self, _)

		self._arg = self._shift(True)
		if self._arg is None:
			return None
		elif self._plain or ('-' == self._arg):
			pass
		elif ('--' == self._arg):
			self._plain = True
			self._arg0 = self._arg = self._shift()
			if self._arg is None:
				return None
		elif self._arg.startswith('--') and ('=' in self._arg):
			m = self._arg
			self._arg0 = self._arg = self.StringObj(m)
			m = m.split('=', 2)
			self._arg.name = m[0][2:]
			self._arg.value = m[1]
			self.get_value = self._get_dde_v
			return True
		elif self._arg.startswith('--'):
			m = self._arg
			self._arg0 = self._arg = self.StringObj(m)
			m = m[2:]
			self._arg.name2 = m
			if m.startswith('no-'):
				self._arg.name = m[3:]
				self._arg.value = False
			elif m.startswith('no'):
				self._arg.name = m[2:]
				self._arg.value = False
			else:
				self._arg.name = m
				self._arg.value = True
			self.get_value = self._get_dd_v
			self.get_bool = self._get_dd_b
			return True
		elif self._arg.startswith('-'):
			m = self._arg
			self._arg0 = self._arg = self.StringObj(m)
			m = m[1:]
			self._arg.bundle = m
			self._arg.index = 0
			self._arg.name2 = m[ self._arg.index ]
			self.get_value = self._get_d_v
			self.get_bool = self._get_d_b
			return True
		self._arg0 = self._arg
		self.get_plain = self._get_p
		return True
	def reject(self):
		self._arg = self._arg0
def dosGlob2RE(s):
	import re;
	s = re.escape(s);
	s = s.replace(r"\*", '.*');
	s = s.replace(r"\?", '.');
	return re.compile(s, re.I);
class Counter:
	def __getattr__(self, name):
		return self.__dict__.setdefault(name, 0);
	def __contains__(self, name):
		return name in self.__dict__;
	def __iter__(self):
		return iter(self.__dict__);
	def __getitem__(self, name):
		return self.__dict__.setdefault(name, 0);
	def __setitem__(self, key, value):
		self.__dict__[key] = value;
	def __str__(self):
		return ' '.join(sorted('%s %d;' % (k, v) for (k, v) in self.__dict__.items()))
def domCanTighten(cur):
	"""
perl -mHTML::Element -e "print qq[(] . join(',',map {qq['$_']} sort(keys(%HTML::Element::canTighten))) . qq[)]"
	"""
	return cur.nodeType in (cur.PROCESSING_INSTRUCTION_NODE, cur.COMMENT_NODE) or \
		cur.localName in ('address','applet','area','base','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','del','dir','div','dl','dt','fieldset','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','hr','html','iframe','ilayer','ins','isindex','label','legend','li','link','map','menu','meta','multicol','noframes','nolayer','noscript','object','ol','optgroup','option','p','param','script','style','table','tbody','td','textarea','tfoot','th','thead','title','tr','ul','~comment','~directive','~literal','~pi')
def htmlIsEmpty(cur):
	#~ perl -mHTML::Element -e "print qq[(] . join(',',map {qq['$_']} sort(keys(%HTML::Element::emptyElement))) . qq[)]"
	return cur.localName in ('area','base','basefont','bgsound','br','col','embed','frame','hr','img','input','isindex','link','meta','param','spacer','wbr','~comment','~declaration','~literal','~pi')

import re;
def domTighten(cur, pre = None):
	t = cur.nodeType
	if t in (cur.TEXT_NODE,):
		x = cur.data;
		if x:
			if cur.nextSibling and cur.previousSibling: # at the middle
				n = (domCanTighten(cur.previousSibling) and 1 or 0) | (domCanTighten(cur.nextSibling) and 2 or 0);
			elif cur.nextSibling: # at start
				n = (domCanTighten(cur.parentNode) and 1 or 0) | (domCanTighten(cur.nextSibling) and 2 or 0);
			elif cur.previousSibling: # at the end
				n = (domCanTighten(cur.previousSibling) and 1 or 0) | (domCanTighten(cur.parentNode) and 2 or 0);
			else: # one and only
				n = (domCanTighten(cur.parentNode) and 3 or 0);
			if n > 2: # 3
				x = re.sub(r'\s+', ' ', x).strip();
			elif n > 1: # 2
				x = re.sub(r'\s+', ' ', x).rstrip();
			elif n > 0: # 1
				x = re.sub(r'\s+', ' ', x).lstrip();
			elif not pre:
				x = re.sub(r'\s+', ' ', x);
		if x:
			cur.data = x;
		else:
			cur.parentNode.removeChild(cur);
	elif t == cur.DOCUMENT_NODE:
		domTighten(cur.documentElement)
	elif t != cur.ELEMENT_NODE:
		return;
	if cur.firstChild:
		cur.normalize()
		pre = pre or (cur.localName in ('pre', 'script', 'style', 'xmp', 'listing', 'plaintext', 'textarea'));
		mae = cur.lastChild;
		while mae:
			x = mae;
			(mae, t) = (x.previousSibling, x.nodeType)
			if t == cur.PROCESSING_INSTRUCTION_NODE:
				cur.removeChild(x);
			elif t == cur.COMMENT_NODE:
				(x.data in ('more', 'nextpage')) or cur.removeChild(x);
			else:
				domTighten(x, pre);
	else:
		if cur.localName in ('span', 'div'):
			cur.parentNode.removeChild(cur);
		elif cur.localName in ('a',):
			cur.appendChild(cur.ownerDocument.createTextNode(""));
		#~ elif cur.localName in ('br',):
			#~ pass;
def domWriteData(out, data):
    if data:
        data = data.replace("&", "&amp;").replace("<", "&lt;").replace("\"", "&quot;").replace(">", "&gt;")
        out.write(data)

def domLastTightenable(cur):
	return domCanTighten(cur.previousSibling) if cur.previousSibling else domCanTighten(cur.parentNode)

def domWritewXML(ctx, cur, out, pre = False, depth = 0):
	#~ return cur.writexml(out)
	t = cur.nodeType
	depth2 = depth + 1
	if cur.ELEMENT_NODE == t:
		thisTightenable = domCanTighten(cur);
		if thisTightenable and (not pre) and domLastTightenable(cur):
			out.write(ctx.newl), out.write(ctx.tab * depth)
		out.write("<" + cur.tagName)
		attrs = cur._get_attributes()
		a_names = attrs.keys()
		a_names.sort()
		for a_name in a_names:
			out.write(" %s=\"" % a_name)
			domWriteData(out, attrs[a_name].value)
			out.write("\"")
		if cur.childNodes:
			out.write(">")
			pre2 = pre or (cur.localName in ('pre', 'script', 'style',  'xmp', 'listing', 'plaintext'));
			for node in cur.childNodes:
				domWritewXML(ctx, node, out, pre2, depth2)
			if pre2:
				pass
			elif thisTightenable and (not pre) and (cur.lastChild and domCanTighten(cur.lastChild)):
				out.write(ctx.newl), out.write(ctx.tab * depth)
			out.write("</%s>" % (cur.tagName,))
		else:
			out.write("/>")
	elif cur.TEXT_NODE == t:
		x = cur.data;
		if pre:
			return domWriteData(out, x)
		if domLastTightenable(cur):
			domWriteData(out, x)
		else:
			domWriteData(out, x)
	elif cur.DOCUMENT_NODE == t:
		out.write("<?xml")
		for t in (('version', ctx.version), ('encoding', ctx.encoding), ('standalone', ctx.standalone)):
			t[1] and out.write(' %s="%s"' % t)
		out.write("?>")
		out.write(ctx.newl or "\n")
		for node in cur.childNodes:
			domWritewXML(ctx, node, out, pre, depth) # NOTE: not using depth2
		ctx.newl and out.write(ctx.newl)
	elif cur.CDATA_SECTION_NODE == t:
		x = cur.data;
		if x.find("]]>") >= 0: raise ValueError("']]>' not allowed in a CDATA section")
		out.write("<![CDATA[%s]]>" % x)
	elif cur.COMMENT_NODE == t:
		if (not pre) and domLastTightenable(cur):
			out.write(ctx.newl), out.write(ctx.tab * depth)
		x = cur.data;
		if "--" in x: raise ValueError("'--' is not allowed in a comment node")
		out.write("<!--%s-->" % (x,))
	elif cur.PROCESSING_INSTRUCTION_NODE == t:
		if (not pre) and domLastTightenable(cur):
			out.write(ctx.newl), out.write(ctx.tab * depth)
		out.write("<?%s %s?>" % (cur.target, cur.data))
	else:
		assert(0)

class DOMXMLWriter(object):
	#~ __slots__ = ('tab', 'newl', 'encoding', 'standalone', 'version')
	version = '1.0'
	standalone = 'yes'
	encoding = 'UTF-8'
	tab = '\t'
	newl = '\n'
	def writexml(self, out, cur):
		domWritewXML(self, cur, out, not (self.tab or self.newl))

def getDecl(f):
	decl = {};
	def onDecl(version, encoding, standalone):
		decl['version'] = version;
		decl['encoding'] = encoding;
		decl['standalone'] = standalone;
	from xml.parsers.expat import ParserCreate;
	p = ParserCreate()
	p.XmlDeclHandler = onDecl;
	if hasattr(f, 'read'):
		p.ParseFile(f);
	else:
		f = open(f, 'rb');
		try:
			p.ParseFile(f);
		finally:
			f.close();
	return decl;

class Sink:
	def __init__(self, out, enc):
		self.out = out;
		self.enc = enc;
	def write(self, x):
		self.out.write(x.encode(self.enc, 'xmlcharrefreplace'));
	def close(self,):
		pass

class SinkRaw:
	def __init__(self, out, enc):
		self.out = out;
		self.enc = enc;
	def write(self, x):
		self.out.write(x);
	def close(self,):
		pass

class HashSink(object):
	__slots__ = ('h',)
	def __init__(self, h = None):
		if not h:
			from hashlib import md5;
			h = md5();
		self.h = h;
	def write(self, x):
		self.h.update(x);

import re
re_sw = re.compile("\s+")
def stripWS(cur, ps = None):
	ps = ((1 == cur.nodeType) and (cur.getAttribute('xml:space') == 'preserve')) or ps
	e = cur.firstChild
	while e:
		(n, t, e) = (e, e.nodeType, e.nextSibling)
		if 1 == t:
			stripWS(n, ps)
		elif (t == n.TEXT_NODE) and not ps:
			t = n.data.strip()
			if len(t) > 0:
				n.data = re_sw.sub(' ', t)
			else:
				cur.removeChild(n)
	return cur

def hashXMLNode(node):
	from hashlib import md5;
	class hashSink:
		def __init__(self, h):
			self.h = h;
		def write(self, x):
			self.h.update(x.encode('UTF-8'));
	h = md5();
	s = hashSink(h);
	node.writexml(s);
	return h.hexdigest();

def domLoadDoc(file, opt):
	from xml.dom.minidom import parse
	doc = parse(file)
	if opt.modeHTML:
		(opt.stripWS or opt.savePretty) and domTighten(doc)
	else:
		opt.stripWS and stripWS(doc)
	return doc

def domWriteDoc(doc, out, enc, ctx):
	w = ctx.domWriter
	w.encoding = enc
	w.writexml(out, doc)

from os import listdir;
from os.path import join;
import logging;
def listdr(f0):
	try:
		return listdir(f0.path);
	except:
		logging.exception("Failed to list %r", f0.path);
	return ();

class fsinfo:
	def __init__(self, p):
		self.path= p;
	def __getattr__(self, name):
		if name == 'stat':
			from os import stat;
			self.__dict__[name] = stat(self.path);
		elif name in ('parent', 'name'):
			from os.path import split;
			(self.__dict__['parent'], self.__dict__['name']) = split(self.path);
		elif 'isdir' == name:
			from stat import S_ISDIR;
			self.__dict__[name] = bool(S_ISDIR(self.stat.st_mode));
		elif hasattr(self.stat, name):
			self.__dict__[name] = getattr(self.stat, name);
		return self.__dict__[name];

def walk_dir_pre(f0):
	d2 = f0.depth + 1;
	for name in listdr(f0):
		f1 = f0.__class__(join(f0.path, name));
		f1.depth = d2;
		f1.rel = join(f0.rel, name);
		f1.walk = None;
		yield f1;
		if f1.walk:
			for x in walk_dir_pre(f1):
				yield x;

def loadModule(ctx, value):
	from imp import find_module, load_module;
	from os.path import splitext, basename, isfile, dirname;
	(mo, parent, title) = (None, dirname(value), basename(value));
	if isfile(value):
		(title, _) = splitext(title);
	if parent:
		mo = find_module(title, [parent])
	else:
		mo = find_module(title)
	if mo:
		mo = load_module(title, *mo);
	return mo;

def init_app(app):
	return
gCounterMap = {}
def getCounter(name):
	global gCounterMap
	if name not in gCounterMap:
		gCounterMap[name] = Counter()
	return gCounterMap[name]
TOT = getCounter('AlterX')

from os.path import abspath;
import logging
gUselxml = None
def onFile(f, ctx):
	ctx.filePath = f = abspath(f);
	TOT.Total += 1;
	# Load document
	try:
		ctx.domDoc = ctx.domParse(f);
	except:
		TOT.Error += 1;
		return logging.exception("Failed to load %r", f);
	else:
		logging.info("XML: %s %s", (ctx.domDoc and ("[#%d]" % TOT.Total) or "ERROR"), f);
		#~ say2("XML:", ctx.domDoc and ("[#%d]" % TOT.Total) or "ERROR", ctx.useEncoding or ctx.domEncoding(ctx.domDoc) or "ASCII", f);
	# Feed to plugins
	if ctx.checksModification:
		if ctx.modifyIf == 2:
			ctx.hashOfDOM = mHash = ctx.domHash(ctx.domDoc)
		else:
			mHash = None
			ctx.hashOfDOM = ctx.domHash(ctx.domDoc)
	else:
		mHash = (ctx.modifyIf == 2) and ctx.domHash(ctx.domDoc)
	mUrge = None;
	#TODO: optimize
	for _ in (_ for _ in (ctx.domCallStart, ctx.domCall, ctx.domCallEnd) if _):
		r = None
		for x in ctx.plugIns:
			r = getattr(x, _, None)
			#~ say1(x, _, r)
			if r and r(ctx.domDoc, ctx):
				mUrge = True; # call back says he modified it
	# Was modified?
	if mHash: # (ctx.modifyIf == 2) Modify if hash changed
		mSave = not (ctx.domHash(ctx.domDoc) == mHash);
	else:
		mSave = mUrge or (ctx.modifyIf > 2);
	if not mSave:
		return None;
	# Modified, Save it
	encoding = ctx.useEncoding or ctx.domEncoding(ctx.domDoc) or "ASCII";
	if (not ctx.dryRun):
		out = None
		if len(ctx.fileOut) < 1: # []
			out = ctx.domSinkFile(ctx.filePath, encoding)
		elif (len(ctx.fileOut) == 1) and (ctx.fileOut[0] == '-'): # ['-']
			out = ctx.domSinkOut(encoding)
		else: # ['file1', ...]
			out = ctx.domSinkFile(ctx.fileOut.pop(0), encoding)
		ctx.domWrite(ctx.domDoc, out, encoding, ctx)
		out = out.close();
		ctx.domDoc = None
	TOT.Altered += 1;
	logging.info("XML: Altered %s %r", (ctx.dryRun and '?' or '!'), encoding and ('[' + encoding + ']') or '');

class App(object):
	def __contains__(self, name):
		return (name in self.__dict__)
	def __setitem__(self, key, value):
		self.__dict__[key] = value
	def __getitem__(self, name):
		return getattr(self, name)

def main(app):
	app.stripWS = None
	app.stripPIs = None
	app.stripCDatas = None
	app.stripComments = None
	app.useLXML = None
	app.useEncoding = None
	app.useNL = ""
	app.useIndent = ""
	app.useTab = ""
	app.savePretty = None
	app.dryRun = None
	app.deBug = None
	app.modifyIf = 0
	app.fileOut = []
	app.fileInc = []
	app.plugIns = []
	app.nameRE = []
	app.modeHTML = None
	app.checksModification = None
	init_app(app)
	args = []
	mo = None
	### Logging
	from logging import basicConfig, INFO, DEBUG
	basicConfig(**{'level' : INFO, 'format' : '%(levelname)s: %(message)s'})
	opt = iteropt();
	while opt.next():
		if opt.is_plain():
			args.append(opt.plain)
	# Module:
		elif opt.is_string('plugin', 'p'):
			mo = None
			try:
				mo = loadModule(app, opt.string);
			finally:
				logging.info("XML: Module %r %r", mo and getattr(mo, '__name__', '') or '', opt.string);
			if mo:
				app.plugIns.append(mo);
				if app.useLXML is None and getattr(mo, 'on_xml_etree', None):
					app.useLXML = True
				if hasattr(mo, 'on_xml_init'): mo.on_xml_init(app)
				mo = getattr(mo, 'on_xml_args', None);
				# register_xml_class, register_xml_calback
		# If there is a module option callback, give him the first chance to pop the option.
		# If he pops an option, go to next. Notice that he can't use SHORT and PLAIN option
		elif mo and opt.is_long_form() and (mo(app, opt) or True) and (not opt.is_valid()):
			continue;
	# Misc:
		elif opt.is_bool('h', 'help'): # --help, --no-help, --help, -h
			pass
		elif opt.is_bool('dry-run', 'n'):
			app.dryRun = opt.bool;
		elif opt.is_bool('act'):
			if opt.bool:
				app.dryRun = False;
		elif opt.is_bool('debug'):
			app.deBug = opt.bool;
	# Pretty XML
		elif opt.is_bool('stripws'):
			app.stripWS = opt.bool;
		elif opt.is_bool('pretty'): # --pretty, --no-pretty, --nopretty
			app.useIndent = "";
			app.useTab = "\t";
			app.useNL = "\n";
			app.savePretty = True;
		elif opt.is_string('newl'):
			app.useNL = opt.string;
		elif opt.is_string('indent'):
			app.useIndent = opt.string;
		elif opt.is_string('add-indent'):
			app.useTab = opt.string;
	# Save
		elif opt.is_string('encoding'):
			app.useEncoding = opt.string;
		elif opt.is_string('o', 'out'):
			app.fileOut.append(opt.string);
		elif opt.is_string('i', 'include'): # -i FILE, --include FILE -iFILE
			app.fileInc.append(opt.string);
		elif opt.is_true('m', 'modify'):
			app.modifyIf += 1;
		elif opt.is_true('mforce'): # Modify whatsoever [3] -mmm, -mforce
			app.modifyIf = 3;
		elif opt.is_true('mhash'): # Modify if hash changed [2] -mm, --mhash
			app.modifyIf = 2;
		elif opt.is_true('murge'): # Modify if told by callbacks [1] -m, --murge
			app.modifyIf = 1;
	# Walker
		elif opt.is_string('name', 'g'):
			app.nameRE.append(dosGlob2RE(opt.string));
		elif opt.is_string('rname' 'e'):
			from re import compile;
			app.nameRE.append(compile(opt.string));
		elif opt.is_true('html'):
			app.modeHTML = opt.bool;
		elif opt.is_true('lxml'):
			app.useLXML = opt.bool;
		# else:
			# assert(False)
	# Call: on_xml_start (give chance to modify app)
	for x in app.plugIns:
		hasattr(x, 'on_xml_start') and x.on_xml_start(app);
	# Options
	#   ...
	# Globing
	if len(app.nameRE) < 1:
		from re import compile;
		app.nameRE.append(compile(app.modeHTML and r"^.+\.(x?html?)$" or r"^.+\.(?:xs(?:d|l)|xml)$"));
	#
	if app.useLXML:
		import sys, codecs
		try:
			from lxml import etree
			is_lxml=True
		except ImportError:
			try: # Python 2.5
				import xml.etree.cElementTree as etree
			except ImportError:
				try: # Python 2.5
					import xml.etree.ElementTree as etree
				except ImportError:
					try: # Normal cElementTree install
						import cElementTree as etree
					except ImportError:
						try: # Normal ElementTree install
							import elementtree.ElementTree as etree
						except ImportError:
							return logging.exception("Failed to import ElementTree from any known place");
			is_lxml=False
		def lxmlParse(f):
			kwargs = {}
			if is_lxml:
				kwargs['remove_blank_text'] = app.stripWS
				kwargs['remove_comments'] = app.stripComments
				kwargs['remove_pis'] = app.stripPIs
				kwargs['strip_cdata'] = app.stripCDatas
			if app.modeHTML:
				from lxml import html
				with open(f, "rb") as si:
					return html.parse(si)
			else:
				parser = etree.XMLParser(**kwargs)
			return etree.parse(open(f, "rb"), parser)
		def domHash(doc):
			h = HashSink()
			doc.write(h)
			return h.h.hexdigest();
		def domWrite(doc, out, enc, ctx):
			doc.write(out, xml_declaration=True, encoding=enc, pretty_print=ctx.savePretty)
		app.domEncoding = lambda doc: getDecl(app.filePath).get('encoding')
		app.domWrite = domWrite
		app.domParse = lxmlParse
		app.domHash = domHash
		app.domSinkFile = lambda f, enc: open(f, 'wb')
		app.domSinkOut = lambda enc: SinkRaw(sys.stdout, enc)
		app.domCall = 'on_xml_etree'
		app.domCallStart = 'on_xml_etree_start'
		app.domCallEnd = 'on_xml_etree_end'
		app.etree = etree
	else:
		import sys, codecs;
		app.domEncoding = lambda doc: getDecl(app.filePath).get('encoding')
		app.domHash = lambda doc: hashXMLNode(doc)
		app.domParse = lambda f: domLoadDoc(f, app)
		app.domSinkFile = lambda f, enc: codecs.open(f, 'wb', enc, 'xmlcharrefreplace')
		app.domSinkOut = lambda enc: Sink(sys.stdout, enc)
		app.domCall = 'on_xml_doc'
		app.domCallStart = 'on_xml_doc_start'
		app.domCallEnd = 'on_xml_doc_end'
		f = app.domWriter = DOMXMLWriter()
		if app.savePretty:
			f.tab = '  '
			f.newl = '\n'
		else:
			f.tab = None
			f.newl = None
		#~ app.domWrite = lambda doc, out, enc, ctx: doc.writexml(out, indent=ctx.useIndent, addindent=ctx.useTab, newl=ctx.useNL, encoding=enc)
		app.domWrite = domWriteDoc
	if app.checksModification:
		def wasModified():
			hash = app.domHash(app.domDoc)
			return hash and app.hashOfDOM and app.hashOfDOM != hash
		app.wasModified = wasModified
	# walk
	from os.path import isfile, isdir
	import os, sys
	_T = lambda _: _;
	if os.name == 'nt':
		if sys.hexversion < 0x03000000:
			_T = getattr(__import__('__builtin__'), 'unicode', None);
	for f in args:
		if f == '-':
			from sys import stdin;
			line = stdin.readline().strip();
			while line:
				onFile(line, app);
				line = stdin.readline().strip();
			continue
		f = _T(f)
		if isfile(f):
			onFile(f, app);
		elif isdir(f):
			f = fsinfo(f);
			f.depth = 0;
			f.rel = '';
			for f in walk_dir_pre(f):
				if f.isdir:
					f.walk = True;
					continue;
				x = f.name;
				for r in app.nameRE:
					if r.match(x):
						onFile(f.path, app);
						break;
		else:
			#TODO: URLs
			raise RuntimeError("File not found `%s'" % f);
	# Call: on_xml_end
	for x in app.plugIns:
		hasattr(x, 'on_xml_end')  and x.on_xml_end(app);
	# finish
	if len(TOT.__dict__):
		TOT.Kept = TOT.Total - TOT.Altered - TOT.Error;
	for k in gCounterMap:
		v = gCounterMap[k]
		len(v.__dict__) 		and logging.info("%s: %s", k, ' '.join(('%s %d;' % (k, v) for (k, v) in v.__dict__.items())));
if __name__ == "__main__":
	from sys import exit
	exit(main(App()))
r"""
""";
